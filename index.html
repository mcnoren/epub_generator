<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB Studio v3 - Import & Edit</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f3f4f6;
            --surface: #ffffff;
            --border: #e5e7eb;
            --text: #1f2937;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .book-meta { display: flex; gap: 0.5rem; }
        input[type="text"] {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 6px;
        }

        .btn-group { display: flex; gap: 0.5rem; align-items: center; }
        
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover { opacity: 0.9; }
        
        button.secondary { background: white; color: var(--text); border: 1px solid var(--border); }
        button.secondary:hover { background: #f9fafb; }

        input[type="file"] { display: none; }
        .upload-label {
            cursor: pointer;
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .upload-label:hover { background: #f9fafb; }

        /* Main Layout */
        main {
            display: grid;
            grid-template-columns: 280px 1fr;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        aside {
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .chapter-list { flex: 1; overflow-y: auto; list-style: none; padding: 0; margin: 0; }
        .chapter-item {
            padding: 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }
        .chapter-item.active { background: #eef2ff; border-left: 4px solid var(--primary); color: var(--primary); }
        .sidebar-actions { padding: 1rem; border-top: 1px solid var(--border); }
        .sidebar-actions button { width: 100%; }

        /* Editor Area */
        section.editor-wrapper {
            background: #e5e5e5;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            padding: 2rem;
        }

        .paper {
            background: white;
            width: 100%;
            max-width: 800px;
            min-height: 100%; /* Fill space */
            padding: 4rem 5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar */
        .toolbar {
            position: sticky;
            top: 0;
            background: white;
            padding: 0.5rem 0;
            border-bottom: 2px solid #f3f4f6;
            margin-bottom: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 5;
        }
        .toolbar button {
            background: white;
            color: #4b5563;
            border: 1px solid #e5e7eb;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }
        .toolbar button:hover { background: #f3f4f6; }

        /* Rich Text Input */
        input#chapter-title {
            font-size: 2rem;
            font-weight: 800;
            border: none;
            margin-bottom: 1rem;
            width: 100%;
            font-family: 'Times New Roman', serif;
            outline: none;
        }

        #rich-editor {
            flex: 1;
            outline: none;
            font-size: 1.15rem;
            line-height: 1.6;
            font-family: 'Times New Roman', Georgia, serif;
            text-align: justify;
        }
        
        /* Simulating the "Novel Look" inside the editor */
        #rich-editor p {
            margin-top: 0;
            margin-bottom: 0;
            text-indent: 1.5em;
        }
        #rich-editor h1, #rich-editor h2 { text-align: center; }
        #rich-editor img { max-width: 100%; height: auto; display: block; margin: 1rem auto; }

        /* Loading Overlay */
        #loader {
            position: fixed; inset: 0; background: rgba(255,255,255,0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; font-size: 1.5rem; color: var(--primary);
            display: none;
        }
    </style>
</head>
<body>

<div id="loader">Processing EPUB...</div>

<header>
    <div class="book-meta">
        <input type="text" id="book-title" placeholder="Book Title">
        <input type="text" id="book-author" placeholder="Author">
    </div>
    <div class="btn-group">
        <label class="upload-label">
            Import EPUB
            <input type="file" id="file-input" accept=".epub" onchange="importEPUB(this)">
        </label>
        <button onclick="generateEPUB()">Export EPUB</button>
    </div>
</header>

<main>
    <aside>
        <ul class="chapter-list" id="chapter-list"></ul>
        <div class="sidebar-actions">
            <button onclick="addNewChapter()">+ New Chapter</button>
        </div>
    </aside>

    <section class="editor-wrapper">
        <div class="paper">
            <input type="text" id="chapter-title" placeholder="Chapter Title" oninput="saveCurrentState()">
            
            <div class="toolbar">
                <button onclick="document.execCommand('bold')"><b>B</b></button>
                <button onclick="document.execCommand('italic')"><i>I</i></button>
                <button onclick="document.execCommand('formatBlock', false, 'h2')">H2</button>
                <button onclick="document.execCommand('formatBlock', false, 'p')">P</button>
                <button onclick="document.execCommand('removeFormat')">Clear</button>
            </div>

            <div id="rich-editor" contenteditable="true" oninput="saveCurrentState()">
                <p>Start writing here...</p>
            </div>
        </div>
    </section>
</main>

<script>
    // --- State Management ---
    let chapters = [];
    let currentChapterId = null;

    // --- Core Logic ---

    function renderList() {
        const list = document.getElementById('chapter-list');
        list.innerHTML = '';
        chapters.forEach((chapter, index) => {
            const li = document.createElement('li');
            li.className = `chapter-item ${chapter.id === currentChapterId ? 'active' : ''}`;
            li.innerHTML = `<span>${chapter.title || 'Chapter ' + (index+1)}</span>`;
            li.onclick = () => selectChapter(chapter.id);
            list.appendChild(li);
        });
    }

    function selectChapter(id) {
        currentChapterId = id;
        const chapter = chapters.find(c => c.id === id);
        if(!chapter) return;
        
        document.getElementById('chapter-title').value = chapter.title;
        document.getElementById('rich-editor').innerHTML = chapter.content; // Load HTML
        renderList();
    }

    function addNewChapter() {
        const newId = Date.now();
        chapters.push({ id: newId, title: "New Chapter", content: "<p>New chapter content...</p>" });
        selectChapter(newId);
    }

    function saveCurrentState() {
        const chapter = chapters.find(c => c.id === currentChapterId);
        if(chapter) {
            chapter.title = document.getElementById('chapter-title').value;
            chapter.content = document.getElementById('rich-editor').innerHTML; // Save HTML
            
            // Update list name if title changes
            const activeItem = document.querySelector('.chapter-item.active span');
            if(activeItem) activeItem.textContent = chapter.title;
        }
    }

    // Initialize default if empty
    if(chapters.length === 0) addNewChapter();


    // --- IMPORT LOGIC (The Hard Part) ---

    async function importEPUB(input) {
        if (!input.files[0]) return;
        
        document.getElementById('loader').style.display = 'flex';
        const file = input.files[0];
        const zip = new JSZip();

        try {
            const content = await zip.loadAsync(file);
            
            // 1. Find Container to locate OPF
            const containerXml = await content.file("META-INF/container.xml").async("text");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(containerXml, "text/xml");
            const rootFile = xmlDoc.getElementsByTagName("rootfile")[0];
            const opfPath = rootFile.getAttribute("full-path");
            const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/')); // Directory of OPF

            // 2. Parse OPF
            const opfContent = await content.file(opfPath).async("text");
            const opfDoc = parser.parseFromString(opfContent, "text/xml");
            
            // Get Metadata
            const title = opfDoc.getElementsByTagName("dc:title")[0]?.textContent || "Imported Book";
            const author = opfDoc.getElementsByTagName("dc:creator")[0]?.textContent || "Unknown";
            document.getElementById('book-title').value = title;
            document.getElementById('book-author').value = author;

            // Get Manifest (Files) and Spine (Order)
            const manifest = {};
            Array.from(opfDoc.getElementsByTagName("item")).forEach(item => {
                manifest[item.getAttribute("id")] = item.getAttribute("href");
            });

            const spineRefs = Array.from(opfDoc.getElementsByTagName("itemref")).map(ref => ref.getAttribute("idref"));

            // 3. Extract Chapters
            const newChapters = [];
            
            for (let i = 0; i < spineRefs.length; i++) {
                const id = spineRefs[i];
                const href = manifest[id];
                if (!href) continue;

                // Handle path relative to OPF location
                const fullPath = opfDir ? `${opfDir}/${href}` : href;
                
                // Read File
                const fileData = await content.file(fullPath)?.async("text");
                if (!fileData) continue;

                const chapDoc = parser.parseFromString(fileData, "application/xhtml+xml") || parser.parseFromString(fileData, "text/html");
                
                // EXTRACT BODY CONTENT
                // We want to keep formatting (<b>, <i>, <p>) but strip full page HTML/HEAD tags
                let bodyContent = chapDoc.body.innerHTML;

                // 4. IMAGE FIXER (Advanced)
                // If the HTML contains <img src="../Images/cover.jpg">, we need to find that file in Zip,
                // convert to Base64, and inject it so the browser can see it.
                const imgs = chapDoc.body.getElementsByTagName("img");
                for (let img of imgs) {
                    const imgSrc = img.getAttribute("src");
                    // Resolve relative path logic (simplified)
                    // This is "best effort" for a single file app
                    let imgPath = resolvePath(fullPath, imgSrc);
                    
                    if (content.file(imgPath)) {
                        const imgBlob = await content.file(imgPath).async("base64");
                        // Guess mime type based on extension
                        const ext = imgPath.split('.').pop();
                        const mime = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'image/png';
                        // Replace src with data URI
                        // We must do this on the string because 'imgs' is a live collection linked to the doc, 
                        // but we are grabbing innerHTML string later. 
                        // Actually, manipulating the DOM is better.
                        img.setAttribute("src", `data:${mime};base64,${imgBlob}`);
                    }
                }
                
                // Get Chapter Title (try h1, then title tag, then fallback)
                let chapTitle = chapDoc.querySelector("title")?.textContent;
                const h1 = chapDoc.querySelector("h1");
                if (h1 && h1.textContent.length < 50) chapTitle = h1.textContent;

                newChapters.push({
                    id: Date.now() + i,
                    title: chapTitle || `Chapter ${i+1}`,
                    content: chapDoc.body.innerHTML // Save the HTML with Base64 images
                });
            }

            chapters = newChapters;
            if(chapters.length > 0) selectChapter(chapters[0].id);

        } catch (e) {
            alert("Error reading EPUB: " + e.message);
            console.error(e);
        } finally {
            document.getElementById('loader').style.display = 'none';
        }
    }

    // Helper for Import Path Resolution
    function resolvePath(currentFile, targetLink) {
        // currentFile = OEBPS/Text/chap1.xhtml
        // targetLink = ../Images/pic.jpg
        const parts = currentFile.split('/');
        parts.pop(); // Remove filename
        
        const targetParts = targetLink.split('/');
        
        for (let part of targetParts) {
            if (part === '..') parts.pop();
            else if (part !== '.') parts.push(part);
        }
        return parts.join('/');
    }

    // --- EXPORT LOGIC (Updated for Rich Text) ---
    async function generateEPUB() {
        const zip = new JSZip();
        const title = document.getElementById('book-title').value || "Untitled";
        const author = document.getElementById('book-author').value || "Unknown";
        const uuid = 'urn:uuid:' + crypto.randomUUID();

        zip.file("mimetype", "application/epub+zip", { compression: "STORE" });
        zip.folder("META-INF").file("container.xml", `<?xml version="1.0"?><container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"><rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>`);

        const oebps = zip.folder("OEBPS");

        // CSS: Ensures generated book looks clean regardless of input messiness
        const cssContent = `
            body { font-family: 'Times New Roman', serif; line-height: 1.5; padding: 0 1em; }
            img { max-width: 100%; height: auto; }
            p { margin: 0; text-indent: 1.5em; text-align: justify; }
            h1, h2 { text-align: center; text-indent: 0; }
            /* Fix indentation on paragraphs following headers */
            h1 + p, h2 + p, h3 + p { text-indent: 0; }
        `;
        oebps.file("style.css", cssContent);

        let manifestItems = `<item id="css" href="style.css" media-type="text/css" />\n`;
        let spineItems = ``;
        let navMap = ``;

        // Loop Chapters
        chapters.forEach((chapter, index) => {
            const filename = `chapter_${index + 1}.xhtml`;
            const fileId = `chapter_${index + 1}`;
            
            // Clean up content slightly (ensure it's valid XHTML inside body)
            // Note: In a production app, use a DOMParser to serialize strict XHTML.
            // Here we wrap user content in a div to catch loose text.
            
            const xhtml = `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>${chapter.title}</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
    <h1>${chapter.title}</h1>
    <div class="chapter-content">
        ${chapter.content}
    </div>
</body>
</html>`;

            oebps.file(filename, xhtml);

            manifestItems += `<item id="${fileId}" href="${filename}" media-type="application/xhtml+xml" />\n`;
            spineItems += `<itemref idref="${fileId}" />\n`;
            
            navMap += `<navPoint id="navPoint-${index + 1}" playOrder="${index + 1}"><navLabel><text>${chapter.title}</text></navLabel><content src="${filename}" /></navPoint>`;
        });

        // Content.opf
        const opfContent = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="3.0">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <dc:title>${title}</dc:title>
        <dc:creator>${author}</dc:creator>
        <dc:identifier id="BookId">${uuid}</dc:identifier>
        <dc:language>en</dc:language>
    </metadata>
    <manifest>
        <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
        ${manifestItems}
    </manifest>
    <spine toc="ncx">${spineItems}</spine>
</package>`;

        oebps.file("content.opf", opfContent);
        
        // NCX
        const ncxContent = `<?xml version="1.0" encoding="UTF-8"?><ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"><head><meta name="dtb:uid" content="${uuid}"/></head><docTitle><text>${title}</text></docTitle><navMap>${navMap}</navMap></ncx>`;
        oebps.file("toc.ncx", ncxContent);

        // Download
        zip.generateAsync({ type: "blob" }).then(function(content) {
            const url = window.URL.createObjectURL(content);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.epub`;
            a.click();
        });
    }
</script>

</body>
</html>
