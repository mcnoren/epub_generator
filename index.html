<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB Studio v8 - Lossless Roundtrip</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- RESET --- */
        * { box-sizing: border-box; }
        :root { --bg: #f3f4f6; --surface: #ffffff; --border: #e5e7eb; --accent: #2563eb; }
        body { margin: 0; background: var(--bg); font-family: system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* --- LAYOUT --- */
        header { height: 50px; background: var(--surface); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 1rem; justify-content: space-between; flex-shrink: 0; }
        .title { font-weight: 600; font-size: 14px; color: #374151; }
        .actions { display: flex; gap: 8px; }
        
        button, .btn { padding: 6px 12px; font-size: 13px; border-radius: 4px; border: 1px solid #d1d5db; background: white; cursor: pointer; color: #374151; }
        button:hover, .btn:hover { background: #f9fafb; border-color: #9ca3af; }
        .btn-primary { background: var(--accent); color: white; border: none; }
        .btn-primary:hover { background: #1d4ed8; }
        input[type="file"] { display: none; }

        main { display: flex; flex: 1; height: calc(100vh - 50px); }

        /* Sidebar */
        aside { width: 250px; background: var(--surface); border-right: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; }
        .file-list { flex: 1; overflow-y: auto; list-style: none; padding: 0; margin: 0; }
        .file-item { padding: 8px 12px; font-size: 13px; border-bottom: 1px solid #f3f4f6; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .file-item:hover { background: #f3f4f6; }
        .file-item.active { background: #eff6ff; color: var(--accent); border-left: 3px solid var(--accent); }
        .sidebar-header { padding: 10px; font-size: 11px; font-weight: bold; text-transform: uppercase; color: #6b7280; background: #f9fafb; border-bottom: 1px solid var(--border); }

        /* Editor */
        .editor-container { flex: 1; display: flex; flex-direction: column; background: #e5e7eb; }
        .toolbar { height: 40px; background: var(--surface); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 10px; gap: 5px; flex-shrink: 0; }
        
        .canvas { flex: 1; overflow: auto; padding: 40px; display: flex; justify-content: center; }
        .page { width: 100%; max-width: 800px; min-height: 100%; background: white; padding: 50px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); outline: none; }
        
        /* The Content Itself */
        #editor { font-family: 'Times New Roman', serif; font-size: 18px; line-height: 1.6; }
        #editor img { max-width: 100%; }

        /* Loader */
        #loader { position: fixed; inset: 0; background: rgba(255,255,255,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        #loader.active { display: flex; }
        .spinner { width: 30px; height: 30px; border: 3px solid #e5e7eb; border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div id="status">Ready</div>
</div>

<header>
    <div class="title" id="doc-title">No Document Loaded</div>
    <div class="actions">
        <label class="btn">
            Open EPUB
            <input type="file" accept=".epub" onchange="loadEPUB(this)">
        </label>
        <button class="btn-primary" onclick="saveEPUB()">Save & Export</button>
    </div>
</header>

<main>
    <aside>
        <div class="sidebar-header">Chapters (Spine)</div>
        <ul class="file-list" id="spine-list"></ul>
    </aside>

    <div class="editor-container">
        <div class="toolbar">
            <button onclick="fmt('bold')"><b>B</b></button>
            <button onclick="fmt('italic')"><i>I</i></button>
            <button onclick="fmt('formatBlock','h2')">Heading</button>
            <button onclick="fmt('formatBlock','p')">Para</button>
        </div>
        <div class="canvas">
            <div id="editor" class="page" contenteditable="true" oninput="markDirty()">
                <p style="color:#6b7280; text-align:center; margin-top:50px;">Import an EPUB to begin editing.</p>
            </div>
        </div>
    </div>
</main>

<script>
    // --- GLOBAL STORE ---
    // This is the "Brain". We store the raw binary of files we don't touch,
    // and the text strings of files we do touch.
    let epubFiles = {};  // Map: filename -> { data: Blob/Text, type: "binary"|"text" }
    let spine = [];      // Array of filenames in reading order
    let currentFile = null;
    let isDirty = false;

    // --- UTILS ---
    const get = id => document.getElementById(id);
    const fmt = (c, v) => document.execCommand(c, false, v);
    const setStatus = msg => { get('status').innerText = msg; get('loader').classList.add('active'); };
    const hideStatus = () => get('loader').classList.remove('active');

    // --- IMPORT ENGINE ---
    async function loadEPUB(input) {
        if(!input.files[0]) return;
        setStatus("Unpacking...");
        
        try {
            const zip = new JSZip();
            const content = await zip.loadAsync(input.files[0]);
            
            // 1. Reset Global Store
            epubFiles = {};
            spine = [];
            currentFile = null;

            // 2. Load EVERYTHING into Memory (Preservation Phase)
            // We iterate every single file in the zip.
            for (let filename in content.files) {
                if (content.files[filename].dir) continue;
                
                // Decide if text or binary
                const lower = filename.toLowerCase();
                const isText = lower.endsWith('.xml') || lower.endsWith('.html') || lower.endsWith('.xhtml') || lower.endsWith('.opf') || lower.endsWith('.ncx') || lower.endsWith('.css') || lower.endsWith('.svg');
                
                if (isText) {
                    const textData = await content.file(filename).async("text");
                    epubFiles[filename] = { data: textData, type: "text" };
                } else {
                    const blobData = await content.file(filename).async("blob");
                    epubFiles[filename] = { data: blobData, type: "binary" };
                }
            }

            // 3. Find the OPF to determine Spine (Reading Order)
            let opfPath = null;
            
            // Try standard container.xml method
            if (epubFiles["META-INF/container.xml"]) {
                const xml = new DOMParser().parseFromString(epubFiles["META-INF/container.xml"].data, "text/xml");
                opfPath = xml.getElementsByTagName("rootfile")[0]?.getAttribute("full-path");
            }
            
            // Fallback: search for any .opf
            if (!opfPath) {
                opfPath = Object.keys(epubFiles).find(f => f.endsWith('.opf'));
            }

            if (!opfPath) throw new Error("Invalid EPUB: No OPF found.");

            // 4. Parse OPF to build Spine
            const opfDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')) : '';
            const opfDoc = new DOMParser().parseFromString(epubFiles[opfPath].data, "text/xml");
            
            // Get Manifest (ID -> Href)
            const manifest = {};
            Array.from(opfDoc.getElementsByTagName("item")).forEach(item => {
                manifest[item.getAttribute("id")] = item.getAttribute("href");
            });

            // Get Spine (List of IDs)
            Array.from(opfDoc.getElementsByTagName("itemref")).forEach(ref => {
                const id = ref.getAttribute("idref");
                let href = manifest[id];
                if (href) {
                    // Resolve relative path
                    href = decodeURI(href);
                    const fullPath = opfDir ? `${opfDir}/${href}` : href;
                    spine.push(fullPath);
                }
            });

            get('doc-title').innerText = opfDoc.getElementsByTagName("dc:title")[0]?.textContent || "Untitled Book";

            // 5. Render Sidebar
            renderSidebar();
            
            // 6. Load First Chapter
            if(spine.length > 0) openChapter(spine[0]);

            hideStatus();

        } catch (e) {
            console.error(e);
            alert("Error: " + e.message);
            hideStatus();
        }
    }

    // --- UI LOGIC ---
    function renderSidebar() {
        const list = get('spine-list');
        list.innerHTML = '';
        spine.forEach((path, index) => {
            const li = document.createElement('li');
            li.className = 'file-item';
            li.textContent = path.split('/').pop(); // Show just filename
            li.onclick = () => openChapter(path);
            if (path === currentFile) li.classList.add('active');
            list.appendChild(li);
        });
    }

    function openChapter(path) {
        // Save previous if dirty
        if (currentFile && isDirty) saveCurrentFileInMemory();

        currentFile = path;
        isDirty = false;
        
        // Find file in memory
        // We need fuzzy matching because zips are case sensitive but some OBFs aren't
        let fileKey = Object.keys(epubFiles).find(k => k.toLowerCase() === path.toLowerCase());
        
        if (!fileKey) {
            get('editor').innerHTML = "<p>Error: File not found in zip.</p>";
            return;
        }

        // Render HTML
        const rawHTML = epubFiles[fileKey].data;
        
        // We need to inject the CSS and Images so they show up in the editor
        // Strategy: Base64 everything? No, that breaks on export.
        // Strategy: Blob URLs.
        const previewHTML = processHTMLForPreview(rawHTML, path);
        
        get('editor').innerHTML = previewHTML;
        renderSidebar(); // Update active state
    }

    function markDirty() {
        isDirty = true;
    }

    function saveCurrentFileInMemory() {
        if (!currentFile) return;
        
        // We need to take the editor content and wrap it back into the original HTML structure
        // But wait! The editor only shows the BODY. We stored the FULL HTML in `epubFiles`.
        
        let fileKey = Object.keys(epubFiles).find(k => k.toLowerCase() === currentFile.toLowerCase());
        const originalDoc = new DOMParser().parseFromString(epubFiles[fileKey].data, "text/html");
        
        // Update Body
        // Note: We need to reverse the "Preview Processing" (stripping blob URLs)
        // But simplified: We just accept that the editor content is the new body content.
        // Images might be tricky. For now, we assume user didn't change image src.
        
        originalDoc.body.innerHTML = get('editor').innerHTML;
        
        // Serialize back to string
        epubFiles[fileKey].data = new XMLSerializer().serializeToString(originalDoc);
        isDirty = false;
    }

    // --- PREVIEW RENDERER (Crucial for Images) ---
    // Turns relative paths (../images/cover.jpg) into Blob URLs (blob:http://...) so the browser renders them
    function processHTMLForPreview(html, currentPath) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        
        // Fix Images
        doc.querySelectorAll('img, image, link[rel="stylesheet"]').forEach(el => {
            const attr = el.tagName === 'LINK' ? 'href' : (el.getAttribute('src') ? 'src' : 'xlink:href');
            const val = el.getAttribute(attr);
            if (!val) return;

            // Resolve Path
            const absPath = resolvePath(currentPath, val);
            
            // Find Blob
            const fileKey = Object.keys(epubFiles).find(k => k.toLowerCase() === absPath.toLowerCase());
            if (fileKey && epubFiles[fileKey]) {
                const blob = epubFiles[fileKey].data;
                // If it's text (css), make a blob
                const blobObj = (epubFiles[fileKey].type === 'text') 
                    ? new Blob([blob], {type: 'text/css'}) 
                    : blob;
                
                const url = URL.createObjectURL(blobObj);
                el.setAttribute(attr, url);
                el.setAttribute('data-original-src', val); // Remember original!
            }
        });

        return doc.body.innerHTML;
    }

    function resolvePath(base, relative) {
        const stack = base.split('/');
        stack.pop();
        const parts = relative.split('/');
        for (let p of parts) {
            if (p === '.') continue;
            if (p === '..') stack.pop();
            else stack.push(p);
        }
        return stack.join('/');
    }

    // --- EXPORT ENGINE ---
    async function saveEPUB() {
        if (isDirty) saveCurrentFileInMemory();
        setStatus("Repacking...");

        setTimeout(async () => {
            const zip = new JSZip();

            // Add all files from memory
            for (let filename in epubFiles) {
                let content = epubFiles[filename].data;
                
                // If it's an HTML file, we need to ensure we strip those Blob URLs back to original paths!
                if (epubFiles[filename].type === 'text' && filename.match(/\.(html|xhtml)$/i)) {
                    content = restoreOriginalPaths(content);
                }

                zip.file(filename, content);
            }

            const blob = await zip.generateAsync({type: "blob"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "edited_book.epub";
            a.click();
            hideStatus();
        }, 100);
    }

    function restoreOriginalPaths(htmlString) {
        // This is a rough cleanup to remove the blob: URLs we injected for preview
        // In a production app, we would use DOMParser, check 'data-original-src', and restore it.
        // For this demo, we rely on the fact that we saved the structure in `saveCurrentFileInMemory`
        // using `originalDoc`.
        
        // However, if the user *edited* the DOM, the `data-original-src` attributes are still there.
        // We just need to swap them back.
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, "text/html");
        
        doc.querySelectorAll('[data-original-src]').forEach(el => {
            const original = el.getAttribute('data-original-src');
            const attr = el.tagName === 'LINK' ? 'href' : (el.getAttribute('src') ? 'src' : 'xlink:href');
            el.setAttribute(attr, original);
            el.removeAttribute('data-original-src');
        });
        
        return new XMLSerializer().serializeToString(doc);
    }

</script>
</body>
</html>
